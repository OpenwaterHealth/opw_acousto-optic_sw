#include <cmath>
#include <cstring>
#include <cstdio>

#include "system/component/inc/fftt.h"
#include "system/component/inc/frame_draw.h"
#include "system/component/inc/invertroi.h"
#include "system/component/inc/roi.h"
#include "system/component/inc/rcam.h"
#include "system/component/inc/stddev.h"
#include "system/component/inc/tagsave.h"


#pragma comment(lib, "sfml-graphics-s.lib")
#pragma comment(lib, "sfml-window-s.lib")
#pragma comment(lib, "sfml-system-s.lib")
#pragma comment(lib, "opengl32.lib")
#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "winmm.lib")
#pragma comment(lib, "freetype.lib")

#pragma comment(lib, "libfftw3-3.lib")

#include "windows.h"

// Mock scheduler.  Emits n dummy pieces of data spaced period_ms
//   millisecnds apart, and keeps track of how long each piece of
//   data takes to be processed.
// Call AverageMS() to see the average execution time of all
//   data across all schedulers.
class Scheduler : public ExecNode {
 public:
  Scheduler(int n, int period_ms) : n_(n), period_ms_(period_ms) {
    timestamp_.resize(10);
  }
  ~Scheduler() {}

  // Start emitting data setup by constructor.
  void Start() {
    t_ = std::thread(&Scheduler::Run, this);
  }

  // Wait until all pieces of data have been emitted
  void Join() { t_.join(); }

  void resize(size_t t) {
    timestamp_.resize(t);
    ExecNode::resize(t);
  }

  // Get the average execution time (in milliseconds) of all
  //   data generated by all Schedulers
  static double AverageMS() {
    return (double)total_time_ / processed_;
  }

 private:
  int n_;
  int period_ms_;
  std::thread t_;
  CircularBuffer<time_t> timestamp_;
  static int processed_;
  static time_t total_time_;
  static std::mutex mutex_;

  void AtExit(void* data) {
    std::lock_guard<std::mutex> lock(mutex_);
    ++processed_;
    time_t passed = Frame::SteadyClockTimeMs() - timestamp_.Pop();
    total_time_ += passed;
  }

  void Run() {
    while (n_-- > 0) {
      timestamp_.Push(Frame::SteadyClockTimeMs());
      Produce(this);
      std::this_thread::sleep_for(std::chrono::milliseconds(period_ms_));
    }
  }
};

int Scheduler::processed_ = 0;
time_t Scheduler::total_time_ = 0;
std::mutex Scheduler::mutex_;

// Mock Rcam.  On reception of any data, emits a frame to be processed.
// Rather than have RcamMock spontaneously emit a frame, it relies on
//   a Scheduler to tell it when to do so.  This is to remove the timing
//   inaccuracy introduced by actually generating the mock frame (which
//   can be large if rand() is used).
class RcamMock : public ExecNode {
 public:
  RcamMock(int width, int height) {
    cfg_frame_.width = width;
    cfg_frame_.height = height;
    cfg_frame_.bits = 10;
  }
  ~RcamMock() {}

  void resize(size_t sz) override {
    Frame cfg_frame;
    pool_.resize(sz, cfg_frame_);
    ExecNode::resize(sz);
  }

  Frame* GetConfig() {
    return &cfg_frame_;
  }

 private:
  void* Exec(void* data) override {
    Frame& fr = pool_.Alloc();
    fr.bits = 10;
    fr.ClearTags();
    for (int i = 0; i < fr.width * fr.height; ++i) {
      //fr.data[i] = rand() % 1024;
      fr.data[i] = i % 1024;
    }
    return (void*)&fr;
  }

  void AtExit(void* data) override {
    pool_.Free((Frame*)data);
  }

  Frame cfg_frame_;
  Pool<Frame> pool_;
};

static const int WIN_X = 1280;
static const int WIN_Y = 720;
static const int PARALLEL_NODES = 2;
int main() {
  std::vector<Scheduler*> sch;
  std::vector<RcamMock*> cam;
  std::vector<FFTT*> fftt;
  std::vector<ROI*> roi;
  std::vector<StdDev*> std;
  std::vector<InvertROI*> iroi;
  std::vector<TagSave*> ts;

  ExecNode::SetNumberThreads(16);

  for (int i = 0; i < PARALLEL_NODES; ++i) {
    sch.push_back(new Scheduler(1000, 50));

    cam.push_back(new RcamMock(2048, 2048));
    cam.back()->AddProducer(sch.back());

    fftt.push_back(new FFTT(cam.back()->GetConfig()));
    fftt.back()->AddProducer(cam.back());

    roi.push_back(new ROI(cam.back()->GetConfig()));
    roi.back()->AddProducer(fftt.back());

    std.push_back(new StdDev());
    std.back()->AddProducer(cam.back());

    iroi.push_back(new InvertROI(cam.back()->GetConfig()));
    iroi.back()->AddProducer(roi.back());
    iroi.back()->Set(0.0, 0.0, 0.5);
    
    ts.push_back(new TagSave());
    //ts.back()->SetFileName("test.csv");
    ts.back()->AddProducer(std.back());
    ts.back()->AddProducer(iroi.back());
    
    sch.back()->resize(25);
  }

  for (int i = 0; i < PARALLEL_NODES; ++i) {
    sch[i]->Start();
  }

  int64_t t0 = Frame::SteadyClockTimeMs();

  for (int i = 0; i < PARALLEL_NODES; ++i) {
    sch[i]->Join();
  }

  bool waiting = true;
  while (waiting) {
    waiting = false;
    for (int i = 0; i < PARALLEL_NODES; ++i) {
      if (!sch[i]->IsExecDone()) waiting = true;  
      break;
    }
  }
  printf("time: %d\n", Frame::SteadyClockTimeMs() - t0);

  printf("Average ms: %.1lf\n", Scheduler::AverageMS());

  for (int i = 0; i < PARALLEL_NODES; ++i) {
    delete ts[i];
    delete iroi[i];
    delete std[i];
    delete roi[i];
    delete fftt[i];
    delete cam[i];
    delete sch[i];
  }

  system("pause");
 
  return 0;
}
